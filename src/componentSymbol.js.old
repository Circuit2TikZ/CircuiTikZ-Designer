/**
 * @module componentSymbol
 */
import { getNamedTag, getNamedTags } from "./xmlHelper";

const METADATA_NAMESPACE_URI = "urn:uuid:c93d8327-175d-40b7-bdf7-03205e4f8fc3";

/**
 * @typedef {object} TikZAnchor
 * @property {string} [name] - the anchor name; e.g. G for the gate of a transistor
 * @property {SVGLength} x - anchor x coordinate relative to the symbol coordinates
 * @property {SVGLength} y - anchor y coordinate relative to the symbol coordinates; positive y is downward (!= TikZ)
 * @property {boolean} isDefault - true, if the anchor is the default one for placing the node
 */

export default class componentSymbol {
	/** @type {SVGSymbolElement} */
	svgElement;
	/** @type {SVGMetadataElement|null} */
	svgMetadataElement;

	/** @type {TikZAnchor[]} */
	pins = [];

	/** @type {TikZAnchor[]} */
	additionalAnchors = [];

	/** @type {TikZAnchor|null} */
	textAnchor = null;

	/** @type {TikZAnchor|null} */
	defaultAnchor = null;

	/**
	 *
	 * @param {SVGSymbolElement} symbolElement
	 */
	constructor(symbolElement) {
		this.svgElement = symbolElement;
		this.svgMetadataElement =
			Array.prototype.find.call(symbolElement.children, (e) => e instanceof SVGMetadataElement) ?? null;

		// parse symbol
		let componentInformation =
			this.svgMetadataElement &&
			getNamedTag(this.svgMetadataElement, "componentinformation", METADATA_NAMESPACE_URI);

		let pins = componentInformation && getNamedTag(componentInformation, "pins", METADATA_NAMESPACE_URI);
		let additionalAnchors =
			componentInformation && getNamedTag(componentInformation, "additionalAnchors", METADATA_NAMESPACE_URI);
		let textPosition =
			componentInformation && getNamedTag(componentInformation, "textPosition", METADATA_NAMESPACE_URI);

		let pinArray = pins ? getNamedTags(pins, "pin", METADATA_NAMESPACE_URI) : [];
		let additionalAnchorArray = additionalAnchors
			? getNamedTags(additionalAnchors, "pin", METADATA_NAMESPACE_URI)
			: [];

		this.pins = pinArray.map(this.#parseAnchor);
		this.additionalAnchors = additionalAnchorArray.map(this.#parseAnchor);

		if (textPosition) {
			this.textAnchor = this.#parseAnchor(textPosition);
		}
	}

	/**
	 * Parses an anchor taf (pin, anchor and textPosition). If `isDefault` is set, `this.defaultAnchor` will be set.
	 *
	 * @private
	 *
	 * @param {Element} anchorElement - the element to parse
	 * @returns {TikZAnchor} the parsed anchor
	 */
	#parseAnchor(anchorElement) {
		const numberRegEx = /^(\d*\.)?\d+$/; // "1", ".1", "1.1"; but not "1."
		/** @type {TikZAnchor} */
		let anchor = {
			name: anchorElement.getAttribute("anchorName") || anchorElement.getAttribute("anchorname") || undefined,
			x: anchorElement.getAttribute("x") ?? 0,
			y: anchorElement.getAttribute("y") ?? 0,
			isDefault: anchorElement.getAttribute("isDefault") || anchorElement.getAttribute("isdefault") || false,
		};
		if (typeof anchor.x === "string" && numberRegEx.test(anchor.x)) anchor.x = Number.parseFloat(anchor.x);
		if (typeof anchor.y === "string" && numberRegEx.test(anchor.y)) anchor.y = Number.parseFloat(anchor.y);
		if (typeof anchor.isDefault !== "boolean") anchor.isDefault = anchor.isDefault === "true";

		if (anchor.isDefault) this.defaultAnchor = anchor;

		return anchor;
	}

	/**
	 * Gets all anchors, which make sense for snapping to the grid.
	 * Does not return the `textAnchor`.
	 *
	 * @returns {TikZAnchor[]} all anchors for snapping to the grid
	 */
	get snappingAnchors() {
		return [...this.pins, ...this.additionalAnchors];
	}
}
